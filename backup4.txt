using System;
using System.Windows.Forms;
using GTA;
using GTA.Native;
using GTA.Math;

namespace ModName // IMPORTANT REPLACE THIS WITH YOUR MODS NAME
{
    public class StuntJumps : Script
    {
        /// These variables are for Mod Information on startup
        bool firstTime = true;
        string ModName = "Stunt Jumps";
        string Developer = "scriptHijo";
        string Version = "1.0";
        string stats;

        Player player = Game.Player;
        Ped ped = Game.Player.Character;

        float startRoll;
        float startPitch;
        float startYaw;
        float startSpeed;

        float roll = 0;
        float pitch = 0;
        Vector3 rotVect;
        float yaw = 0;

        float maxYaw = 0;
        float maxPitch = 0;
        float maxRoll = 0;

        float pitchRot = 0;
        float yawRot = 0;
        float rollRot = 0;

        float degRotated = 0;

        float score = 0;
        float totalScore = 0;
        float highScore = 0;

        int multiply;

        bool fresh = true;
        bool hasFlipped = false;
        bool detected = false;

        bool backflip = false;
        bool forwardflip = false;
        bool clockwise;
        bool counterclockwise;



        public StuntJumps()
        {
            Tick += onTick;
            Interval = 1;
        }

        private void onTick(object sender, EventArgs e)
        {
            // Mod info
            if (firstTime)
            {
                UI.Notify(ModName + " " + Version + " by " + Developer + " Loaded");
                firstTime = false;
            }
            if (ped.IsInVehicle())
            {
                Vehicle veh = ped.CurrentVehicle;
                roll = Function.Call<float>(Hash.GET_ENTITY_ROLL, veh);
                pitch = Function.Call<float>(Hash.GET_ENTITY_PITCH, veh);
                rotVect = Function.Call<Vector3>(Hash.GET_ENTITY_ROTATION, veh, false);
                yaw = rotVect.Z;

                if (Function.Call<bool>(Hash.IS_ENTITY_IN_AIR, veh))
                {

                    if (fresh)
                    {
                        maxYaw = yaw;
                        maxPitch = pitch;
                        maxRoll = roll;

                        startSpeed = veh.Speed;
                        fresh = false;
                    }

                    if (checkFlip(maxPitch, pitch) > 90 && !backflip && !forwardflip)
                    {
                        backflip = true;
                        forwardflip = false;
                        detected = true;
                    }
                    else if (checkFlip(maxPitch, pitch) < -90 && !backflip && !forwardflip)
                    {
                        forwardflip = true;
                        backflip = false;
                        detected = true;
                    }

                    if (detected)
                    {
                        if(flipped(maxPitch, pitch))
                        {
                            hasFlipped = true;
                        }


                        if(!hasFlipped)
                        {
                            if (pitch > maxPitch && backflip)
                            {
                                pitchRot += changeInDegrees(maxPitch, pitch);
                                maxPitch = pitch;
                            }
                            else if(pitch < maxPitch && forwardflip)
                            {
                                pitchRot += changeInDegrees(maxPitch, pitch);
                                maxPitch = pitch;
                            }
                        }
                        else
                        {
                            if (pitch < maxPitch && backflip)
                            {
                                pitchRot += changeInDegrees(maxPitch, pitch);
                                maxPitch = pitch;
                            }
                            else if (pitch > maxPitch && forwardflip)
                            {
                                pitchRot += changeInDegrees(maxPitch, pitch);
                                maxPitch = pitch;
                            }
                        }
                        
                    }

                    degRotated = pitchRot + yawRot + rollRot;

                    if ((int)degRotated / 360 < 1)
                    {
                        multiply = 1;
                    }
                    else multiply = (int)degRotated / 360;

                    score = (degRotated * multiply) + (startSpeed / 10);

                    if (score > 0)
                    {
                        stats = "Score: ~b~" + score.ToString("F") + "~s~ , Multiplier: ~g~~h~" + multiply;
                        Function.Call(Hash._SET_TEXT_COMPONENT_FORMAT, "STRING");
                        Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, stats);
                        Function.Call(Hash._0x238FFE5C7B0498A6ï»¿, 0, 0, 0, -1);
                    }

                }
                else
                {


                    if (!fresh)
                    {

                        fresh = true;
                        degRotated = pitchRot + yawRot + rollRot;

                        if (ped.IsInVehicle() && !veh.IsUpsideDown && degRotated > 180)
                        {


                            totalScore += score;
                            if (score > highScore)
                                highScore = score;

                            UI.Notify("Score: ~g~" + score);
                            UI.Notify("High Score: ~b~" + highScore);
                            UI.Notify("Total Score: ~r~" + totalScore);

                        }

                        pitchRot = 0;
                        yawRot = 0;
                        rollRot = 0;

                        backflip = false;
                        forwardflip = false;
                        detected = true;

                    }

                }


            }

        }


        private float changeInDegrees(float oldDegree, float newDegree)
        {

            return Math.Abs(Math.Abs(oldDegree) - Math.Abs(newDegree));
        }

        private float checkFlip(float deg1, float deg2)
        {
            return deg2 - deg1;
        }

        private bool flipped(float prev, float cur)
        {
            if (prev < 0 && cur > 0)
                return true;
            else if (cur < 0 && prev > 0)
                return true;
            else return false;
        }

    }
}
